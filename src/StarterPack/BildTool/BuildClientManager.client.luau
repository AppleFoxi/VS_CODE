-- BuildClientManager (LocalScript –≤ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–µ)
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local PhysicsService = game:GetService("PhysicsService")
local UserInputService = game:GetService("UserInputService")
local player = Players.LocalPlayer
local mouse = player:GetMouse()

local tool = script.Parent
local remoteEvent = ReplicatedStorage:WaitForChild("BuildBlockEvent")
local gridSize = 4
local previewBlock = nil
local canBuild = false
local isOnCooldown = false
local lastPosition = nil
local connection = nil

-- –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∫—É–ª–¥–∞—É–Ω–∞
local COOLDOWN_TIME = 0.5
local lastBuildTime = 0

-- –°—Å—ã–ª–∫–∞ –Ω–∞ –º–æ–¥—É–ª—å UI
local UITool = nil
local success, message = pcall(function()
	UITool = require(tool:WaitForChild("UITool"))
end)
if not success then
	warn("–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å UITool: " .. tostring(message))
	return
end

print("‚úÖ BuildClientManager: RemoteEvent –∏ UITool –Ω–∞–π–¥–µ–Ω—ã")

-- –§—É–Ω–∫—Ü–∏—è –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏—è –ø–æ —Å–µ—Ç–∫–µ
local function snapToGrid(position)
    return Vector3.new(
        math.floor(position.X / gridSize) * gridSize + gridSize/2,
        math.floor(position.Y / gridSize) * gridSize + gridSize/2,
        math.floor(position.Z / gridSize) * gridSize + gridSize/2
    )
end

-- –ü–æ–ª—É—á–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏ —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–∞ (—É–ø—Ä–æ—â–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è)
local function getBuildPosition()
    if not mouse.Target then return nil end
    
    -- –ë–ª–∞–≥–æ–¥–∞—Ä—è CanQuery = false, –ø—Ä–µ–≤—å—é-–±–ª–æ–∫–∏ –∏–≥–Ω–æ—Ä–∏—Ä—É—é—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏
    if player.Character and mouse.Target:IsDescendantOf(player.Character) then
        return nil
    end
    
    local hitPosition = mouse.Hit.Position
    local surfaceNormal = mouse.TargetSurface
    
    -- –°–º–µ—â–∞–µ–º –ø–æ–∑–∏—Ü–∏—é –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –≥—Ä–∞–Ω–∏
    local offset = Vector3.new(0, gridSize/2, 0)
    if surfaceNormal == Enum.NormalId.Front then
        offset = Vector3.new(0, 0, gridSize/2)
    elseif surfaceNormal == Enum.NormalId.Back then
        offset = Vector3.new(0, 0, -gridSize/2)
    elseif surfaceNormal == Enum.NormalId.Right then
        offset = Vector3.new(gridSize/2, 0, 0)
    elseif surfaceNormal == Enum.NormalId.Left then
        offset = Vector3.new(-gridSize/2, 0, 0)
    elseif surfaceNormal == Enum.NormalId.Bottom then
        offset = Vector3.new(0, -gridSize/2, 0)
    end
    
    return snapToGrid(hitPosition + offset)
end

-- –ü—Ä–æ–≤–µ—Ä–∫–∞ –º–æ–∂–Ω–æ –ª–∏ —Å—Ç—Ä–æ–∏—Ç—å –Ω–∞ —ç—Ç–æ–π –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏
local function canBuildOnSurface()
    if not mouse.Target then return false end
    return mouse.TargetSurface ~= Enum.NormalId.Bottom
end

-- –£–ø—Ä–æ—â–µ–Ω–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–ª–ª–∏–∑–∏–π
local function checkCollision(position)
    local testPart = Instance.new("Part")
    testPart.Size = Vector3.new(gridSize - 0.2, gridSize - 0.2, gridSize - 0.2)
    testPart.Position = position
    testPart.Anchored = true
    testPart.CanCollide = false
    testPart.Transparency = 1
    testPart.Parent = workspace

    -- –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º —Ç–æ–ª—å–∫–æ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞ –∏–≥—Ä–æ–∫–∞
    local ignoreList = {testPart}
    if player.Character then
        for _, part in ipairs(player.Character:GetDescendants()) do
            if part:IsA("BasePart") then
                table.insert(ignoreList, part)
            end
        end
    end

    local touchingParts = testPart:GetTouchingParts()
    for _, part in ipairs(touchingParts) do
        -- –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–æ–ª—å–∫–æ –æ–±—ã—á–Ω—ã–µ –∫–æ–ª–ª–∏–∑–∏–æ–Ω–Ω—ã–µ —á–∞—Å—Ç–∏
        if part.Transparency < 0.5 and part.CanCollide then
            testPart:Destroy()
            return true
        end
    end
    testPart:Destroy()
    return false
end

-- –°–æ–∑–¥–∞–Ω–∏–µ –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä–∞ (–±–µ–∑ —Ç–µ–≥–∞)
local function createPreview()
    if previewBlock then previewBlock:Destroy() end

    previewBlock = Instance.new("Part")
    previewBlock.Size = Vector3.new(gridSize - 0.1, gridSize - 0.1, gridSize - 0.1)
    previewBlock.Transparency = 0.7
    previewBlock.Anchored = true
    previewBlock.CanCollide = false
    previewBlock.Material = Enum.Material.Neon
    previewBlock.Name = "BuildPreview"
    
    -- –î–µ–ª–∞–µ–º –±–ª–æ–∫ –Ω–µ–æ–±–Ω–∞—Ä—É–∂–∏–º—ã–º –¥–ª—è –ª—É—á–µ–π –∏ —Ñ–∏–∑–∏–∫–∏
    previewBlock.CanQuery = false
    previewBlock.Massless = true
    
    -- –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º collision groups
    pcall(function()
        if not PhysicsService:GetCollisionGroupName("Preview") then
            PhysicsService:CreateCollisionGroup("Preview")
            PhysicsService:CollisionGroupSetCollidable("Preview", "Default", false)
        end
        previewBlock.CollisionGroup = "Preview"
    end)
    
    previewBlock.Parent = workspace
    return previewBlock
end

-- –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä–∞
local function updatePreview()
    if not previewBlock then return end

    local buildPosition = getBuildPosition()
    if not buildPosition then
        previewBlock.Transparency = 1
        canBuild = false
        return
    end
    
    if lastPosition and (buildPosition - lastPosition).Magnitude < 0.5 then
        return
    end
    lastPosition = buildPosition
    
    -- –ü—Ä–æ–≤–µ—Ä—è–µ–º –º–æ–∂–Ω–æ –ª–∏ —Å—Ç—Ä–æ–∏—Ç—å –Ω–∞ —ç—Ç–æ–π –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏ –∏ –Ω–µ—Ç –ª–∏ –∫–æ–ª–ª–∏–∑–∏–π
    local surfaceValid = canBuildOnSurface()
    local collisionFree = not checkCollision(buildPosition)
    
    canBuild = surfaceValid and collisionFree
    
    previewBlock.Position = buildPosition
    previewBlock.Transparency = 0.7
    
    -- –ú–µ–Ω—è–µ–º —Ü–≤–µ—Ç –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–∞
    if canBuild then
        previewBlock.Color = Color3.fromRGB(50, 255, 50) -- –ó–µ–ª–µ–Ω—ã–π: –º–æ–∂–Ω–æ —Å—Ç—Ä–æ–∏—Ç—å
    elseif not surfaceValid then
        previewBlock.Color = Color3.fromRGB(255, 50, 50) -- –ö—Ä–∞—Å–Ω—ã–π: –Ω–µ–≤–µ—Ä–Ω–∞—è –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç—å
    else
        previewBlock.Color = Color3.fromRGB(255, 150, 50) -- –û—Ä–∞–Ω–∂–µ–≤—ã–π: –∫–æ–ª–ª–∏–∑–∏—è
    end
end

-- –í–∏–∑—É–∞–ª—å–Ω–∞—è –æ–±—Ä–∞—Ç–Ω–∞—è —Å–≤—è–∑—å
local function showBuildFeedback(success)
    if not previewBlock then return end
    
    if success then
        -- –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é –ø–µ—Ä–µ–¥ –ø–æ–∫–∞–∑–æ–º –∫—É–ª–¥–∞—É–Ω–∞
        local mousePos = UserInputService:GetMouseLocation()
        UITool.UpdateCooldownPosition(mousePos.X, mousePos.Y)
        
        previewBlock.Color = Color3.fromRGB(150, 255, 150)
        previewBlock.Transparency = 0.3
        isOnCooldown = true
        lastBuildTime = os.clock()
        UITool.StartCooldown(COOLDOWN_TIME)
    else
        -- –ú–∏–≥–∞–Ω–∏–µ –∫—Ä–∞—Å–Ω—ã–º –ø—Ä–∏ –Ω–µ—É–¥–∞—á–Ω–æ–π –ø–æ–ø—ã—Ç–∫–µ
        previewBlock.Color = Color3.fromRGB(255, 50, 50)
        previewBlock.Transparency = 0.5
        
        delay(0.2, function()
            if previewBlock and previewBlock.Parent then
                previewBlock.Transparency = 0.7
                -- –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–π —Ü–≤–µ—Ç –ø–æ—Å–ª–µ –º–∏–≥–∞–Ω–∏—è
                if canBuildOnSurface() then
                    previewBlock.Color = Color3.fromRGB(50, 255, 50)
                else
                    previewBlock.Color = Color3.fromRGB(255, 50, 50)
                end
            end
        end)
    end
    
    delay(0.3, function()
        if previewBlock and previewBlock.Parent then
            previewBlock.Transparency = 0.7
            -- –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–π —Ü–≤–µ—Ç
            if canBuild then
                previewBlock.Color = Color3.fromRGB(50, 255, 50)
            elseif not canBuildOnSurface() then
                previewBlock.Color = Color3.fromRGB(255, 50, 50)
            else
                previewBlock.Color = Color3.fromRGB(255, 150, 50)
            end
        end
    end)
end

-- –ü—Ä–æ–≤–µ—Ä–∫–∞ –º–æ–∂–Ω–æ –ª–∏ —Å—Ç—Ä–æ–∏—Ç—å (–∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –≤ Activated)
local function canBuildNow()
    if isOnCooldown then return false end
    return canBuild
end

-- –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞
tool.Equipped:Connect(function()
    createPreview()
    UITool.Init()
    connection = RunService.Heartbeat:Connect(updatePreview)
end)

tool.Unequipped:Connect(function()
    if connection then connection:Disconnect() end
    if previewBlock then previewBlock:Destroy() end
    UITool.Cleanup()
    canBuild = false
    isOnCooldown = false
end)

tool.Activated:Connect(function()
    if mouse.Target and previewBlock then
        local buildPosition = getBuildPosition()
        if buildPosition and canBuildNow() and canBuildOnSurface() then
            showBuildFeedback(true)
            remoteEvent:FireServer(previewBlock.Position)
        else
            showBuildFeedback(false)
        end
    else
        showBuildFeedback(false)
    end
end)

-- –í Heartbeat –ø—Ä–æ–≤–µ—Ä—è–µ–º –∑–∞–≤–µ—Ä—à–∏–ª—Å—è –ª–∏ –∫—É–ª–¥–∞—É–Ω
RunService.Heartbeat:Connect(function()
	if isOnCooldown then
		if os.clock() - lastBuildTime >= COOLDOWN_TIME then
			isOnCooldown = false
		end
	end
end)

tool.Destroying:Connect(function()
    if connection then connection:Disconnect() end
    if previewBlock then previewBlock:Destroy() end
    UITool.Cleanup()
end)

print("üõ†Ô∏è BuildClientManager: –ö–ª–∏–µ–Ω—Ç—Å–∫–∏–π —Å–∫—Ä–∏–ø—Ç –≥–æ—Ç–æ–≤! –ü—Ä–µ–≤—å—é —Ç–µ–ø–µ—Ä—å –ø–æ–ª–Ω–æ—Å—Ç—å—é –∏–≥–Ω–æ—Ä–∏—Ä—É–µ—Ç—Å—è.")